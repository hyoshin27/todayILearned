정규표현식이란
문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 검색’하거나 치환하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단이다.


문자열표

.	    아무 문자

[ ]     에 있는 어떤문자 [0-9] -> 0에서 9까지(\d 와 같다) w[ab] -> wa, wb

^	    not (제외) [^0-9] -> 숫자빼고 (\D와 같다)

+	    한개 이상의 문자

*	    문자가 없거나 하나 이상 있으면 일치

?	    문자가 없거나 하나 있으면 일치

{n}	    정확히 n개만을 찾음

{n,}    n개 이상을 찾음

{n,m}	최소 n개, 최대 m개의 경우를 찾음

\v	    수직 탭

\n	    개행

\f	    폼 피드

\r	    캐리지 리턴

\t	    탭

[\b]	백스페이스

\d	    [0-9]와 동일한 기능

\D	    [^0-9]와 동일한 기능

\w	    [a-zA-Z0-9_]와 동일한 기능

\W	    [^a-zA-Z0-9_]와 동일한 기능

\s	    [\f\n\r\t\v]와 동일한 기능

\S	    [^\f\n\r\t\v]와 동일한 기능

\x      16진수 숫자와 일치

\0      8진수 숫자와 일치


예제

1.글자수 만큼 마스킹처리하기

글자수만큼마스킹
@Test
public void 글자수만큼_마스킹(){
    String test = "123456";
    assertEquals(test.replaceAll("[0-9]","*"),"******");
}


2.핸드폰 뒷자리 마스킹

핸드폰뒷자리마스킹
@Test
public void 핸드폰_뒷자리_마스킹(){
    String phone = "010-1234-1234";
    assertEquals(phone.replaceAll("(01[0|1|7|8|9])([-*])(\\d{3,4})([-*])(\\d{4})", "$1$2$3$4****"),"010-1234-****");
}


3.핸드폰 가운데 마스킹

핸드폰가운데마스킹
@Test
public void 핸드폰_가운데_마스킹(){
    String phone = "010-1234-1234";

    assertEquals(phone.replaceAll("^(01[0|1|7|8|9])([-*])(\\d{3,4})([-*])(\\d{4})$", "$1$2****$4$5"),"010-****-1234");
}


4.앞자리 몇개 빼고 마스킹

앞자리몇개빼고마스킹
@Test
public void 앞자리_몇개_뺴고_마스킹(){
    String test = "123456";
    assertEquals(test.replaceAll("(?<=.{1})." , "*") , "1*****");
}


5.앞자리 몇개만 마스킹

앞자리 몇개만 마스킹
@Test
public void 앞자리_몇개만_마스킹(){
    String test = "123456";
    assertEquals(test.replaceAll("(?<!.{1})." , "*") , "*23456");
}


주의

Pattern으로 사용할경우 Pattern.compile은 비용이 비싸기때문에 호출할때마다 연산하도록 하지 않고, 상수화 추천.
