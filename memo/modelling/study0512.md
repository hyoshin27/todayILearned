#객체지향 원리

>추상화

추상화란 사물의 공통된 특징

이것을 분류하면 집합 Class가 된다.

예: 1, ㄱ, a, 2, b, ㄴ, c -> 숫자: 1, 2 한글: ㄱ, ㄴ 영어: a, b, c

>캡슐화

정보의 은닉(높은 응집도와 낮은 결합도를 갖게 함)

응집도(Cohesion)

클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.

결합도(Coupling)

어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타낸다.

데메테르 법칙 : 객체안에서 메소드 호출은 자신의 메소드나 로컬 생성 객체(파라메터로 받은 객체 포함)의 메소드만 호출해야 한다.
         
>일반화

프로그래밍 관점에서 상속관계

속성의 기능이나 기능을 재사용만 강조해서 사용하는 경우가 많으나 이것은 매우 한정적인 시각

내가 생각하기에는 추상화의 반대가 일반화라고 생각되었다


         추상화
자동차    ------>  벤츠, 아우디, 현대
과일     <------   딸기, 배, 사과
          일반화


>다형성

다른 클래스의 객체가 같은 메시지 받았을때 각자의 방법으로 처리하는 수단

다형성과 일반화의 관걔는 코드를 간결하게 할 뿐만 아니라 변화에도 유연하게 대처할 수 있다.

~~~
abstrat class Pet(){
    public abstrat void talk();
}

class Dog extends Pet{
    public void talk() {
        System.out.println("멍멍");
    }
}

class Cat extends Pet{
    public void talk() {
        System.out.println("야옹");
    }
}

public class Main{
    public static groupTalk(Pet[] pets){
        for(Pet pet in pets){
            pet.talk();
        }
    }

    public static void main(String[] args){
        Pet[] pets = {new Dog(), new Cat()};
        groupTalk(pets);
    }
}
~~~


>피터 코드의 상속 규칙

다음 중 하나라도 만족하지 않으면 상속을 사용해서는 안된다.

- 자식 클래스와 부모 클래스 사이는 역할 수행 관계가 아니어야 한다.

-한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 없어야 한다.

-자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.

-자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다.

-자식 클래스가 역할, 트랜잭션, 디바이스 등을 특수화 해야 한다.

느낀점 : 추상화, 캡술화, 일반화의 관계를 알아보고자 블로그 검색을 했는데 대부분 JAVA 객체 지향 디자인 패턴의 정리로 했구나라고 느꼈다

참조 : JAVA 객체 지향 디자인 패턴